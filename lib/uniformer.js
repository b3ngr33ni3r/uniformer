// Generated by CoffeeScript 1.6.3
var defaults, extend, fs, isArray, isBool, isKey, isKv, isNested, isObject, isString, isSupported, procArgs, procFile, typeChange, uniformer;

require('js-yaml');

fs = require('fs');

extend = require('extend');

isArray = Array.isArray || function(value) {
  return {}.toString.call(value) === '[object Array]';
};

isString = function(value) {
  return typeof value === 'string';
};

isBool = function(value) {
  return typeof value === 'boolean';
};

isObject = function(value) {
  return typeof value === 'object';
};

isKey = function(val, keyDefs) {
  var keyDef, _i, _len;
  if (keyDefs == null) {
    keyDefs = ['--', '-'];
  }
  if (isString(val)) {
    for (_i = 0, _len = keyDefs.length; _i < _len; _i++) {
      keyDef = keyDefs[_i];
      if (val.substr(0, keyDef.length) === keyDef) {
        return val.substr(keyDef.length, val.length);
      }
    }
  }
  return false;
};

isNested = function(val) {
  var dotted;
  if (!isString(val)) {
    return false;
  }
  dotted = val.split('.');
  if (dotted.length <= 0) {
    return false;
  } else {
    return dotted;
  }
};

isKv = function(val) {
  var eq, result;
  if (!isString(val)) {
    return false;
  }
  eq = val.split('=');
  if (eq.length <= 0) {
    return false;
  }
  return result = {
    key: eq[0],
    value: eq[1]
  };
};

isSupported = function(key, supported) {
  var support, _i, _len;
  if (supported == null) {
    supported = null;
  }
  if (supported == null) {
    return true;
  }
  for (_i = 0, _len = supported.length; _i < _len; _i++) {
    support = supported[_i];
    if (key === support) {
      return true;
    }
  }
  return false;
};

typeChange = function(val) {
  if (typeof val === 'number') {
    return new Number(val);
  } else if (val.toLowerCase() === 'false') {
    return false;
  } else if (val.toLowerCase() === 'true') {
    return true;
  } else {
    return val;
  }
};

procFile = function(file) {
  if (fs.existsSync(file)) {
    return require(file);
  }
};

procArgs = function(argv) {
  var arg, chunk, cindex, index, key, kv, nested, ptr, root, values, vindex, _i, _j, _k, _len, _len1, _ref;
  root = {};
  for (index = _i = 0, _len = argv.length; _i < _len; index = ++_i) {
    arg = argv[index];
    if ((key = isKey(arg)) !== false) {
      values = [];
      if ((kv = isKv(arg)) !== false) {
        key = kv.key;
        values.push(typeChange(kv.value));
      }
      for (vindex = _j = index, _ref = argv.length - 1; _j <= _ref; vindex = _j += 1) {
        if (!isKey(argv[vindex])) {
          values.push(typeChange(argv[vindex]));
        } else {
          break;
        }
      }
      if (values.length === 1) {
        values = values[0];
      } else if (values.length === 0) {
        values = true;
      }
      if ((nested = isNested(key)) !== false) {
        ptr = root;
        for (cindex = _k = 0, _len1 = nested.length; _k < _len1; cindex = ++_k) {
          chunk = nested[cindex];
          if (cindex < nested.length - 1) {
            if ((ptr[chunk] != null) && !isObject(ptr[chunk])) {
              _debug("argv value tried to override existing structure " + ptr[chunk]);
              break;
            }
            if (ptr[chunk] == null) {
              ptr[chunk] = {};
            }
            ptr = ptr[chunk];
          } else {
            if ((ptr[chunk] != null) && isArray(ptr[chunk])) {
              if (isArray(values)) {
                ptr[chunk] = ptr[chunk].join(values);
              } else {
                ptr[chunk].push(values);
              }
            } else if ((ptr[chunk] != null) && isObject(ptr[chunk])) {
              _debug("argv value tried to override existing structure " + ptr[chunk]);
              break;
            } else if (ptr[chunk] == null) {
              ptr[chunk] = values;
            }
          }
        }
      } else {
        if ((root[key] != null) && isObject(root[key])) {
          _debug("argv value tried to override existing structure " + root[key]);
          continue;
        } else if ((root[key] != null) && isArray(root[key])) {
          if (isArray(values)) {
            root[key] = root[key].join(values);
          } else {
            root[key].push(values);
          }
        } else if (root[key] == null) {
          root[key] = values;
        }
      }
    }
  }
  return root;
};

defaults = {
  argv: process.argv
};

uniformer = function(opts) {
  var processed;
  if (opts == null) {
    opts = null;
  }
  if ((opts != null) && isObject(opts)) {
    opts = extend(true, defaults, opts);
  } else if ((opts != null) && isString(opts)) {
    opts = extend(true, defaults, {
      file: opts
    });
  }
  processed = extend(true, {}, procArgs(opts.argv));
  if ((processed["config"] != null) && !isSupported("config", opts.supported || null)) {
    opts.file = processed["config"];
    delete processed["config"];
  }
  if (opts.file != null) {
    processed = extend(true, procFile(__dirname + "/" + opts.file), processed);
  }
  return processed;
};

module.exports = uniformer;
