// Generated by CoffeeScript 1.6.3
var canMake, defaults, extend, fs, isArray, isBool, isKey, isKeyValid, isKv, isNested, isObject, isString, isSupported, procArgs, procFile, typeChange, uniformer, _debug, _debugState, _supported,
  __slice = [].slice;

require('js-yaml');

fs = require('fs');

extend = require('extend');

_debugState = 'console';

_debug = function() {
  var m, msg, _i, _len, _results;
  msg = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
  switch (_debugState) {
    case 'console':
      _results = [];
      for (_i = 0, _len = msg.length; _i < _len; _i++) {
        m = msg[_i];
        _results.push(console.log(m));
      }
      return _results;
  }
};

isArray = Array.isArray || function(value) {
  return {}.toString.call(value) === '[object Array]';
};

isString = function(value) {
  return typeof value === 'string';
};

isBool = function(value) {
  return typeof value === 'boolean';
};

isObject = function(value) {
  return typeof value === 'object';
};

isKey = function(val, keyDefs) {
  var keyDef, _i, _len;
  if (keyDefs == null) {
    keyDefs = ['--', '-'];
  }
  if (isString(val)) {
    for (_i = 0, _len = keyDefs.length; _i < _len; _i++) {
      keyDef = keyDefs[_i];
      if (val.substr(0, keyDef.length) === keyDef) {
        return val.substr(keyDef.length, val.length);
      }
    }
  }
  return false;
};

isNested = function(val) {
  var dotted;
  if (!isString(val)) {
    return false;
  }
  dotted = val.split('.');
  if (dotted.length <= 1) {
    return false;
  } else {
    return dotted;
  }
};

isKv = function(val) {
  var eq, result;
  if (!isString(val)) {
    return false;
  }
  eq = val.split('=');
  if (eq.length === 1) {
    return false;
  }
  return result = {
    key: eq[0],
    value: eq[1]
  };
};

isKeyValid = function(key) {
  if (key == null) {
    return false;
  }
  if (!isString(key)) {
    return false;
  }
  return true;
};

_supported = null;

isSupported = function(key) {
  var support, _i, _len;
  if (_supported == null) {
    return true;
  }
  for (_i = 0, _len = supported.length; _i < _len; _i++) {
    support = supported[_i];
    if (key === support) {
      return true;
    }
  }
  return false;
};

canMake = function(object, value) {
  if (object == null) {
    return value;
  }
  if (isObject(object)) {
    return false;
  } else if (isArray(object)) {
    if (isArray(value)) {
      return object.concat(value);
    } else {
      return object.push(value);
    }
  } else {
    return value;
  }
};

typeChange = function(val) {
  if (val == null) {
    return val;
  } else if (!isNaN(val)) {
    _debug("typechange to number for " + val);
    return parseInt(val);
  } else if (val.toLowerCase() === 'false') {
    _debug("typechange to false for " + val);
    return false;
  } else if (val.toLowerCase() === 'true') {
    _debug("typechange to true for " + val);
    return true;
  } else {
    _debug("no typechange needed for " + val);
    return val;
  }
};

procFile = function(file) {
  if (fs.existsSync(file)) {
    return require(file);
  }
};

procArgs = function(argv) {
  var aindex, arg, chunk, cindex, entry, key, kv, nest, ptr, root, vals, vindex, _i, _j, _k, _len, _len1, _ref, _ref1;
  root = {};
  for (aindex = _i = 0, _len = argv.length; _i < _len; aindex = ++_i) {
    arg = argv[aindex];
    if ((key = isKey(arg)) !== false) {
      if (isSupported(key && isKeyValid(key))) {
        _debug("key found " + key);
        vals = [];
        for (vindex = _j = _ref = aindex + 1, _ref1 = argv.length - 1; _j <= _ref1; vindex = _j += 1) {
          if (isKey(argv[vindex]) === false) {
            _debug("adding value " + argv[vindex]);
            vals.push(typeChange(argv[vindex]));
            delete argv[vindex];
          } else {
            break;
          }
        }
        if ((kv = isKv(key)) !== false) {
          _debug("kv parsed " + kv.key + "=" + kv.value);
          vals = typeChange(kv.value);
          key = kv.key;
        }
        if (vals.length === 0) {
          _debug("no values found, setting to true");
          vals = true;
        }
        if ((nest = isNested(key)) !== false) {
          _debug("processing nest " + nest.toString());
          ptr = root;
          for (cindex = _k = 0, _len1 = nest.length; _k < _len1; cindex = ++_k) {
            chunk = nest[cindex];
            if (cindex < nest.length - 1) {
              if ((entry = canMake(ptr[chunk], {})) !== false) {
                ptr[chunk] = entry;
              } else {
                _debug("cannot make entry under " + chunk);
              }
            } else {
              if ((entry = canMake(ptr[chunk], vals))) {
                ptr[chunk] = entry;
                _debug("made " + entry + " under " + chunk);
              } else {
                _debug("cannot make entry under " + chunk);
              }
            }
            ptr = ptr[chunk];
          }
        } else {
          if ((entry = canMake(root[key], vals)) !== false) {
            root[key] = entry;
          } else {
            _debug("cannot make entry " + root[key]);
          }
        }
      } else {
        _debug(key + " is not supported");
      }
    }
  }
  return root;
};

defaults = {
  argv: process.argv,
  debug: 'console'
};

uniformer = function(opts) {
  var processed;
  if (opts == null) {
    opts = null;
  }
  if ((opts != null) && isString(opts)) {
    opts = extend(true, defaults, {
      file: opts
    });
  } else {
    opts = extend(true, defaults, opts);
  }
  if (opts['supported'] != null) {
    _supported = opts['supported'];
  } else {
    _supported = null;
  }
  processed = extend(true, {}, procArgs(opts.argv));
  if ((processed["config"] != null) && !isSupported("config")) {
    opts.file = processed["config"];
    delete processed["config"];
  }
  if (opts.file != null) {
    processed = extend(true, procFile(__dirname + "/" + opts.file), processed);
  }
  return processed;
};

module.exports = uniformer;
